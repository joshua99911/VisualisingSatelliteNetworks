{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Satellites Scripts and programs for visualizing and modeling satellite orbits and simulating satellite networks. We use Panda3D to run an interactive 3D view of satellites oribiting around the earth, and use the Skyfield astronomy library to determin the position of the satellites. Setup For the basic set of scripts, we use Panda#D, networkx, and skyfield. To run these, create and activate a Python virtual environment and use pip to install the dependencies. In the base directory: python3 -m venv venv . venv/bin/activate pip install -r requirements.txt Animate Ideal Orbits We use Panda3d elements to simulate the orbits of a satellite network by creating 40 rotating disks inclined at 53 degrees and attaching spheres to the disks represent satellites. Run an animation of a 40x40 LEO satellite conselation: python animate_orbits.py Enter q to quit. Use arrow keys to change the view Calculate Actual Satellite Positions We use the Skyfield astronomy library to calcualte the position of earth satellites. Animate Real Satellite Groups Use TLE files to position and update groups of Satellites in real time: python orbit_set.py [ system [ time-factor] ] The available systems are: - starlink - stations (space stations) - kuiper - GPS - artificial (a 40x40 system) The time-rate defaults to 2X real time, and depending on the number of satellites in the system and the speed of the computer and GPU running the software, may be able to run at 10X real time. You can control the image display: - + and - top zoom in and out (shift + does not yet work) - arrow keys to change the orientation of the world - q to quit Network Topology and Routes Build a topology and routing tables python network.py Satellite Positions Generate satellite positions with Skyfield and CTSC python sat_pos_samples.py Network Topology Utilities to explore a possible network topology of a satellite network where each satellite is a router with 4 ports connecting to neighboring satellites in a torus topology. torus_topo: Generate a networkx graph of a connected set of rings (default 40x40) frr_config_topo: Generate FRR network configurations for a networkx topology test_large_frr: Generate, configure, and exercise a large torus topology Exercise a large torus topology, generate routes, and trace paths: python torus_topo.py Exercise FRR network configuration generation on a small network: python frr_config_topo.py Generate a large torus topology and generate FRR network config information python test_large_frr.py Mininet Emulation Run an mininet based emulation of an FRR based network toplogy. This setup contains two parts: - A mininet process that creates network containers and launches FRR processes. - A physical simulator process that calculates satellite positions and link states. The network emulation uses a FastAPI based interface for control and monitoring and provides a FastAPI user interface. Connect to http://localhost:8000 for the UI. (Substitute name / IP address of VM instance if using a VM and web browser is outside of the VM) Setup Running the full emulation requires Mininet and FRR to be installed as well as the requirements listed in mnet/requriements.txt pip install -r mnet/requirements.txt Since mininet must run as root, it is recommended that you run the full emulation in a VM. See mininet_frr for an environment that will run the full emulation. Run Full Emulation By default the simulation runs with a 4 ring by 4 satellite per ring configuration. You can run a larger config by specifying the number of rings and nodes per ring on the run_mn and geosimsat command links. Obviously these should be the same. Run the mininet environment: sudo python -m mnet.run_mn mnet/configs/small.net Run the satellite location simulation: python geosimsat.py mnet/configs/small.net Run the UI / Sim Stub For development and test, the FastAPI driver and network physical simulator can be run without running mininet and the FRR processes. The mininet python libraries are needed, but FRR does not need to be installed. Running the stub: - is much more light weight - does not run as root - is easy and safe to run without using a VM - does not require FRR to be installed - will not need Mininet to be installed Running the stub simulates that satellite positions and physical events, provides the UI, but does not emulate the network. sudo python -m mnet.run_mn mnet/configs/small.net --no-mnet TODO / Plans The network currently runs an OSPF, staticd, and zebra daemon on each node to exchange. Possible plans include: - Add a flat world map and chart the positions of the satellites - Add ground stations at fixed positions - Create and support a node type: SAT or GROUND - Initially make ground a mininet host. - Create links between ground stations and nearby satellites - Satellites to inject OSPF route for connected ground station - Ground station sets and updates default routes to preferred uplink Adding hosts to connect as staellites move overhead Adding an OF controller to handle host connectivity (at some point) Using an agent on host and satellites for control and connectivity testing Useful Information Skyfield Library Network topology design at 27,000 km.hour Celes Track Satellite Catalog NetworkX draft-li-arch-sat-04","title":"Home"},{"location":"#satellites","text":"Scripts and programs for visualizing and modeling satellite orbits and simulating satellite networks. We use Panda3D to run an interactive 3D view of satellites oribiting around the earth, and use the Skyfield astronomy library to determin the position of the satellites.","title":"Satellites"},{"location":"#setup","text":"For the basic set of scripts, we use Panda#D, networkx, and skyfield. To run these, create and activate a Python virtual environment and use pip to install the dependencies. In the base directory: python3 -m venv venv . venv/bin/activate pip install -r requirements.txt","title":"Setup"},{"location":"#animate-ideal-orbits","text":"We use Panda3d elements to simulate the orbits of a satellite network by creating 40 rotating disks inclined at 53 degrees and attaching spheres to the disks represent satellites. Run an animation of a 40x40 LEO satellite conselation: python animate_orbits.py Enter q to quit. Use arrow keys to change the view","title":"Animate Ideal Orbits"},{"location":"#calculate-actual-satellite-positions","text":"We use the Skyfield astronomy library to calcualte the position of earth satellites.","title":"Calculate Actual Satellite Positions"},{"location":"#animate-real-satellite-groups","text":"Use TLE files to position and update groups of Satellites in real time: python orbit_set.py [ system [ time-factor] ] The available systems are: - starlink - stations (space stations) - kuiper - GPS - artificial (a 40x40 system) The time-rate defaults to 2X real time, and depending on the number of satellites in the system and the speed of the computer and GPU running the software, may be able to run at 10X real time. You can control the image display: - + and - top zoom in and out (shift + does not yet work) - arrow keys to change the orientation of the world - q to quit","title":"Animate Real Satellite Groups"},{"location":"#network-topology-and-routes","text":"Build a topology and routing tables python network.py","title":"Network Topology and Routes"},{"location":"#satellite-positions","text":"Generate satellite positions with Skyfield and CTSC python sat_pos_samples.py","title":"Satellite Positions"},{"location":"#network-topology","text":"Utilities to explore a possible network topology of a satellite network where each satellite is a router with 4 ports connecting to neighboring satellites in a torus topology. torus_topo: Generate a networkx graph of a connected set of rings (default 40x40) frr_config_topo: Generate FRR network configurations for a networkx topology test_large_frr: Generate, configure, and exercise a large torus topology Exercise a large torus topology, generate routes, and trace paths: python torus_topo.py Exercise FRR network configuration generation on a small network: python frr_config_topo.py Generate a large torus topology and generate FRR network config information python test_large_frr.py","title":"Network Topology"},{"location":"#mininet-emulation","text":"Run an mininet based emulation of an FRR based network toplogy. This setup contains two parts: - A mininet process that creates network containers and launches FRR processes. - A physical simulator process that calculates satellite positions and link states. The network emulation uses a FastAPI based interface for control and monitoring and provides a FastAPI user interface. Connect to http://localhost:8000 for the UI. (Substitute name / IP address of VM instance if using a VM and web browser is outside of the VM)","title":"Mininet Emulation"},{"location":"#setup_1","text":"Running the full emulation requires Mininet and FRR to be installed as well as the requirements listed in mnet/requriements.txt pip install -r mnet/requirements.txt Since mininet must run as root, it is recommended that you run the full emulation in a VM. See mininet_frr for an environment that will run the full emulation.","title":"Setup"},{"location":"#run-full-emulation","text":"By default the simulation runs with a 4 ring by 4 satellite per ring configuration. You can run a larger config by specifying the number of rings and nodes per ring on the run_mn and geosimsat command links. Obviously these should be the same. Run the mininet environment: sudo python -m mnet.run_mn mnet/configs/small.net Run the satellite location simulation: python geosimsat.py mnet/configs/small.net","title":"Run Full Emulation"},{"location":"#run-the-ui-sim-stub","text":"For development and test, the FastAPI driver and network physical simulator can be run without running mininet and the FRR processes. The mininet python libraries are needed, but FRR does not need to be installed. Running the stub: - is much more light weight - does not run as root - is easy and safe to run without using a VM - does not require FRR to be installed - will not need Mininet to be installed Running the stub simulates that satellite positions and physical events, provides the UI, but does not emulate the network. sudo python -m mnet.run_mn mnet/configs/small.net --no-mnet","title":"Run the UI / Sim Stub"},{"location":"#todo-plans","text":"The network currently runs an OSPF, staticd, and zebra daemon on each node to exchange. Possible plans include: - Add a flat world map and chart the positions of the satellites - Add ground stations at fixed positions - Create and support a node type: SAT or GROUND - Initially make ground a mininet host. - Create links between ground stations and nearby satellites - Satellites to inject OSPF route for connected ground station - Ground station sets and updates default routes to preferred uplink Adding hosts to connect as staellites move overhead Adding an OF controller to handle host connectivity (at some point) Using an agent on host and satellites for control and connectivity testing","title":"TODO / Plans"},{"location":"#useful-information","text":"Skyfield Library Network topology design at 27,000 km.hour Celes Track Satellite Catalog NetworkX draft-li-arch-sat-04","title":"Useful Information"},{"location":"DocStrings/","text":"Test Function From torus_topo.py Create a torus network of the given size annotated with orbital information. Source code in torus_topo.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def create_network ( num_rings : int = NUM_RINGS , num_ring_nodes : int = NUM_RING_NODES , ground_stations : bool = True ) -> networkx . Graph : ''' Create a torus network of the given size annotated with orbital information. ''' graph : networkx . Graph = networkx . Graph () graph . graph [ \"rings\" ] = num_rings graph . graph [ \"ring_nodes\" ] = num_ring_nodes graph . graph [ \"ring_list\" ] = [] graph . graph [ \"inclination\" ] = 53.9 prev_ring_num = None for ring_num in range ( num_rings ): create_ring ( graph , ring_num , num_ring_nodes ) if prev_ring_num is not None : connect_rings ( graph , prev_ring_num , ring_num , num_ring_nodes ) prev_ring_num = ring_num if prev_ring_num is not None : connect_rings ( graph , prev_ring_num , 0 , num_ring_nodes ) if ground_stations : add_ground_stations ( graph ) # Set all edges to up for edge_name , edge in graph . edges . items (): edge [ \"up\" ] = True return graph Test Function From run_mn.py Configure DNS for all nodes in the network by updating /etc/hosts in each node's namespace. Include interface IPs with descriptive names. Source code in mnet/run_mn.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def configure_dns ( net , graph ): ''' Configure DNS for all nodes in the network by updating /etc/hosts in each node's namespace. Include interface IPs with descriptive names. ''' # First, collect all IP addresses and hostnames hosts_entries = [] # Add satellite nodes loopback addresses for name in torus_topo . satellites ( graph ): node = graph . nodes [ name ] if \"ip\" in node : hosts_entries . append ( f \" { format ( node [ 'ip' ] . ip ) } \\t { name } \" ) # Add interface IPs with descriptive names for neighbor in graph . adj [ name ]: edge = graph . adj [ name ][ neighbor ] local_ip = edge [ \"ip\" ][ name ] remote_ip = edge [ \"ip\" ][ neighbor ] local_intf = edge [ \"intf\" ][ name ] remote_intf = edge [ \"intf\" ][ neighbor ] # Add entries for both local and remote interfaces # Format: IP devicename-intf devicename-TO-neighborname hosts_entries . append ( f \" { format ( local_ip . ip ) } \\t { local_intf } { name } -TO- { neighbor } \" ) hosts_entries . append ( f \" { format ( remote_ip . ip ) } \\t { remote_intf } { neighbor } -TO- { name } \" ) # Add ground stations for name in torus_topo . ground_stations ( graph ): node = graph . nodes [ name ] if \"ip\" in node : hosts_entries . append ( f \" { format ( node [ 'ip' ] . ip ) } \\t { name } \" ) # Create hosts file content hosts_content = \" \\n \" . join ([ \"127.0.0.1 \\t localhost\" , \"::1 \\t localhost ip6-localhost ip6-loopback\" , \"fe00::0 \\t ip6-localnet\" , \"ff00::0 \\t ip6-mcastprefix\" , \"ff02::1 \\t ip6-allnodes\" , \"ff02::2 \\t ip6-allrouters\" , \" \\n # Network hosts\" , * hosts_entries ]) # Update /etc/hosts in each node's namespace for node in net . hosts : # Create a temporary hosts file with open ( '/tmp/hosts.temp' , 'w' ) as f : f . write ( hosts_content ) # Copy the file to the node's namespace node . cmd ( f 'mkdir -p /etc/netns/ { node . name } ' ) node . cmd ( f 'cp /tmp/hosts.temp /etc/netns/ { node . name } /hosts' ) # Also update the current namespace's hosts file node . cmd ( 'cp /tmp/hosts.temp /etc/hosts' ) # Clean up node . cmd ( 'rm /tmp/hosts.temp' ) # Configure resolv.conf to use the hosts file resolv_content = \"nameserver 127.0.0.1 \\n search mininet\" node . cmd ( f 'echo \" { resolv_content } \" > /etc/netns/ { node . name } /resolv.conf' ) node . cmd ( f 'echo \" { resolv_content } \" > /etc/resolv.conf' )","title":"DocStrings"},{"location":"DocStrings/#test-function-from-torus_topopy","text":"Create a torus network of the given size annotated with orbital information. Source code in torus_topo.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def create_network ( num_rings : int = NUM_RINGS , num_ring_nodes : int = NUM_RING_NODES , ground_stations : bool = True ) -> networkx . Graph : ''' Create a torus network of the given size annotated with orbital information. ''' graph : networkx . Graph = networkx . Graph () graph . graph [ \"rings\" ] = num_rings graph . graph [ \"ring_nodes\" ] = num_ring_nodes graph . graph [ \"ring_list\" ] = [] graph . graph [ \"inclination\" ] = 53.9 prev_ring_num = None for ring_num in range ( num_rings ): create_ring ( graph , ring_num , num_ring_nodes ) if prev_ring_num is not None : connect_rings ( graph , prev_ring_num , ring_num , num_ring_nodes ) prev_ring_num = ring_num if prev_ring_num is not None : connect_rings ( graph , prev_ring_num , 0 , num_ring_nodes ) if ground_stations : add_ground_stations ( graph ) # Set all edges to up for edge_name , edge in graph . edges . items (): edge [ \"up\" ] = True return graph","title":"Test Function From torus_topo.py"},{"location":"DocStrings/#test-function-from-run_mnpy","text":"Configure DNS for all nodes in the network by updating /etc/hosts in each node's namespace. Include interface IPs with descriptive names. Source code in mnet/run_mn.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def configure_dns ( net , graph ): ''' Configure DNS for all nodes in the network by updating /etc/hosts in each node's namespace. Include interface IPs with descriptive names. ''' # First, collect all IP addresses and hostnames hosts_entries = [] # Add satellite nodes loopback addresses for name in torus_topo . satellites ( graph ): node = graph . nodes [ name ] if \"ip\" in node : hosts_entries . append ( f \" { format ( node [ 'ip' ] . ip ) } \\t { name } \" ) # Add interface IPs with descriptive names for neighbor in graph . adj [ name ]: edge = graph . adj [ name ][ neighbor ] local_ip = edge [ \"ip\" ][ name ] remote_ip = edge [ \"ip\" ][ neighbor ] local_intf = edge [ \"intf\" ][ name ] remote_intf = edge [ \"intf\" ][ neighbor ] # Add entries for both local and remote interfaces # Format: IP devicename-intf devicename-TO-neighborname hosts_entries . append ( f \" { format ( local_ip . ip ) } \\t { local_intf } { name } -TO- { neighbor } \" ) hosts_entries . append ( f \" { format ( remote_ip . ip ) } \\t { remote_intf } { neighbor } -TO- { name } \" ) # Add ground stations for name in torus_topo . ground_stations ( graph ): node = graph . nodes [ name ] if \"ip\" in node : hosts_entries . append ( f \" { format ( node [ 'ip' ] . ip ) } \\t { name } \" ) # Create hosts file content hosts_content = \" \\n \" . join ([ \"127.0.0.1 \\t localhost\" , \"::1 \\t localhost ip6-localhost ip6-loopback\" , \"fe00::0 \\t ip6-localnet\" , \"ff00::0 \\t ip6-mcastprefix\" , \"ff02::1 \\t ip6-allnodes\" , \"ff02::2 \\t ip6-allrouters\" , \" \\n # Network hosts\" , * hosts_entries ]) # Update /etc/hosts in each node's namespace for node in net . hosts : # Create a temporary hosts file with open ( '/tmp/hosts.temp' , 'w' ) as f : f . write ( hosts_content ) # Copy the file to the node's namespace node . cmd ( f 'mkdir -p /etc/netns/ { node . name } ' ) node . cmd ( f 'cp /tmp/hosts.temp /etc/netns/ { node . name } /hosts' ) # Also update the current namespace's hosts file node . cmd ( 'cp /tmp/hosts.temp /etc/hosts' ) # Clean up node . cmd ( 'rm /tmp/hosts.temp' ) # Configure resolv.conf to use the hosts file resolv_content = \"nameserver 127.0.0.1 \\n search mininet\" node . cmd ( f 'echo \" { resolv_content } \" > /etc/netns/ { node . name } /resolv.conf' ) node . cmd ( f 'echo \" { resolv_content } \" > /etc/resolv.conf' )","title":"Test Function From run_mn.py"},{"location":"about/","text":"This is a prelim about the author and the project","title":"About"},{"location":"about/#this-is-a-prelim-about-the-author-and-the-project","text":"","title":"This is a prelim about the author and the project"}]}